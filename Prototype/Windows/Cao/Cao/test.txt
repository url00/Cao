// Compile with: /D_UNICODE /DUNICODE /DWIN32 /D_WINDOWS /c /F 8000000 ^M
#pragma comment(lib, "user32.lib")^M
^M
#include <Windows.h>^M
#include <CommCtrl.h>^M
#include <stdlib.h>^M
#include <string.h>^M
#include <tchar.h>^M
#include <strsafe.h>^M
#include <io.h>^M
#include <fcntl.h>^M
#include <stdio.h>^M
#include <string>^M
#include <fstream>^M
#include <iostream>^M
#include <assert.h>^M
^M
#include "Main.h"^M
^M
^M
^M
// Global data.^M
static const wchar_t *TITLE = L"Cao";^M
static HWND MyWindow = NULL;^M
static HHOOK KeyboardHook;^M
static HANDLE My_Out = NULL;^M
static bool isWindowShowing = false;^M
^M
^M
^M
static const UINT IconMessage = WM_APP + 9;^M
static NOTIFYICONDATA IconData = { 0 };^M
static HMENU IconMenu;^M
static const UINT __IconMenu_MessageIdStart = 1337;^M
static const UINT IconMenu_RunCancel  = __IconMenu_MessageIdStart + 0;^M
static const UINT IconMenu_Exit       = __IconMenu_MessageIdStart + 1;^M
^M
^M
^M
static bool isChildRunning    = false;^M
static bool wasChildCancelled = false;^M
^M
static HANDLE Child_In_Read   = NULL;^M
static HANDLE Child_In_Write  = NULL;^M
static HANDLE Child_Out_Read  = NULL;^M
static HANDLE Child_Out_Write = NULL;^M
^M
static PROCESS_INFORMATION ChildProcInfo = { 0 };^M
^M
^M
^M
static const wchar_t *configFilename = L"config.txt";^M
static int currentConfigIndex = 0;^M
static int Configs_count = 0;^M
static const int Configs_size = 200;^M
Config Configs[Configs_size];^M
^M
^M
^M
static RAWINPUTDEVICE rawKeyboard = { 0 };^M
static char modState = 0;^M
^M
^M
^M
void^M
LoadConfigFile()^M
{^M
    const int readBuffer_size = 200000;^M
    unsigned char readBuffer[readBuffer_size];^M
    readBuffer[0] = '\0';^M
^M
    HANDLE configFile =^M
        CreateFile(^M
            configFilename,^M
            GENERIC_READ,^M
            0,^M
            NULL,^M
            OPEN_EXISTING, ^M
            FILE_ATTRIBUTE_NORMAL,^M
            NULL);^M
^M
    DWORD bytesRead = 0;^M
    bool readSuccess =^M
        ReadFile(^M
            configFile,^M
            readBuffer,^M
            readBuffer_size,^M
            &bytesRead,^M
            NULL);^M
    if (!readSuccess)^M
    {^M
        // @log err^M
        printf("Could not read from config file!\n");^M
    }^M
^M
    if(!CloseHandle(configFile))^M
    {^M
        // @log err^M
        printf("Could not close config file handle!\n");^M
    }^M
^M
^M
    ^M
    if (bytesRead < 3)^M
    {^M
        // @log err^M
        printf("Invalid config file!\n");^M
        PostQuitMessage(EXIT_FAILURE);^M
        return;^M
    }^M
^M
    // Detect BOM and move past it.^M
    int startingOffset = 0;^M
    bool hasBOM = ^M
        readBuffer[0] == 0xef &&^M
        readBuffer[1] == 0xbb &&^M
        readBuffer[2] == 0xbf;^M
    if (hasBOM)^M
    {^M
        startingOffset = 3;^M
    }^M
    ^M
    ^M
    int lineBuffer_length = 0;^M
    const int lineBuffer_size = 200000;^M
    char lineBuffer[lineBuffer_size];^M
^M
    for (int readBuffer_i = startingOffset; readBuffer_i < bytesRead; readBuffer_i++)^M
    {^M
        bool isLineReady = false;^M
^M
        char readChar = readBuffer[readBuffer_i];^M
        if (readChar == '\r')^M
        {^M
            // Skip the newline character for \r\n endings.^M
            readBuffer_i++;^M
            lineBuffer[lineBuffer_length] = '\0';^M
            isLineReady = true;^M
        }^M
        else if (readChar == '\n')^M
        {^M
            lineBuffer[lineBuffer_length] = '\0';^M
            isLineReady = true;^M
        }^M
        else^M
        {^M
            lineBuffer[lineBuffer_length] = readChar;^M
            lineBuffer_length++;^M
        }^M
^M
        if (isLineReady)^M
        {^M
            Config *currentConfig = &Configs[Configs_count];^M
            char *readCharDest = currentConfig->name;^M
            const char NAME       = 1 << 0;^M
            const char COMMAND    = 1 << 1;^M
            const char HOTKEYMOD  = 1 << 2;^M
            const char HOTKEY     = 1 << 3;^M
            char readMode = NAME;^M
^M
            for (int lineBuffer_i = 0; lineBuffer_i < lineBuffer_length; lineBuffer_i++)^M
            {^M
                char lineChar = lineBuffer[lineBuffer_i];^M
^M
                if (readMode & (NAME | COMMAND))^M
                {^M
                    if (lineChar == '"')^M
                    {^M
                        if (readMode & NAME)^M
                        {^M
                            readCharDest = currentConfig->name;^M
                        }^M
                        else if (readMode & COMMAND)^M
                        {^M
                            readCharDest = currentConfig->command;^M
                        }^M
                    }^M
                    else if (lineChar == ':')^M
                    {^M
                        readMode = COMMAND;^M
                    }^M
                    else if (lineChar == '=')^M
                    {^M
                        readMode = HOTKEYMOD;^M
                    }^M
                    else if (lineChar == '\r' || readChar == '\n')^M
                    {^M
                    }^M
                    else^M
                    {^M
                        char charWithNull[2];^M
                        charWithNull[0] = lineChar;^M
                        charWithNull[1] = '\0';^M
                        strcat_s(readCharDest, 255, charWithNull);^M
                    }^M
                }^M
                else if (readMode & HOTKEYMOD)^M
                {^M
                    if (lineChar == 'c')^M
                    {^M
                        currentConfig->hotkeyMod |= Config_CONTROL;^M
                    }^M
                    else if (lineChar == 'a')^M
                    {^M
                        currentConfig->hotkeyMod |= Config_ALT;^M
                    }^M
                    else if (lineChar == 's')^M
                    {^M
                        currentConfig->hotkeyMod |= Config_SHIFT;^M
                    }^M
                    else if (lineChar == ',')^M
                    {^M
                        readMode = HOTKEY;^M
                    }^M
                    else^M
                    {^M
                        // @log err^M
                        wchar_t errorMessage[255];^M
                        errorMessage[0] = '\0';^M
                        StringCchPrintf(errorMessage, 255, L"Invalid config file! Error position: %d:%d", Configs_count + 1, lineBuffer_i + 1);^M
^M
                        MessageBox(MyWindow, errorMessage, TITLE, MB_OK);^M
                        PostQuitMessage(0);^M
                        return;^M
                    }^M
                }^M
                else if (readMode & HOTKEY)^M
                {^M
                    currentConfig->hotkey = lineChar;^M
                }^M
            }^M
            ^M
            if (!(readMode & (COMMAND | HOTKEY)))^M
            {^M
                // @log err^M
                wchar_t errorMessage[255];^M
                errorMessage[0] = '\0';^M
                StringCchPrintf(errorMessage, 255, L"Invalid config file! Error line: %d", Configs_count + 1);^M
^M
                MessageBox(MyWindow, errorMessage, TITLE, MB_OK);^M
                PostQuitMessage(0);^M
                return;^M
            }^M
            ^M
            lineBuffer_length = 0;^M
            isLineReady = false;^M
            Configs_count++;^M
        }^M
    }^M
}^M
^M
^M
^M
int CALLBACK^M
WinMain(^M
    HINSTANCE Instance,^M
    HINSTANCE PrevInstance,^M
    char      *cmdLine,^M
    int       cmdShow^M
)^M
{^M
    // Set up and display console for debugging.^M
    if (AllocConsole())^M
    {        ^M
        // Set up handle to my standard out. The console needs to exist for the handle to return valid.^M
        My_Out = GetStdHandle(STD_OUTPUT_HANDLE);^M
^M
        FILE *cout;^M
        freopen_s(&cout, "CONOUT$", "w", stdout);^M
        SetConsoleTitle(TITLE);^M
        SetConsoleTextAttribute(My_Out, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);^M
        SetConsoleCtrlHandler(ConsoleCtrlHandler, true);^M
    }^M
    else^M
    {^M
        // @log error, could not initialize console^M
        return EXIT_FAILURE;^M
    }^M
^M
    OutBuffer Buffer;^M
    std::streambuf *sb = std::cout.rdbuf(&Buffer);^M
    std::cout.rdbuf(sb);^M
^M
^M
^M
    // Set up applicaion.^M
    WNDCLASSEX WindowClass    = { 0 };^M
    WindowClass.cbSize	      = sizeof(WNDCLASSEX);^M
    WindowClass.style         = CS_HREDRAW | CS_VREDRAW;^M
    WindowClass.lpfnWndProc   = WndProc;^M
    WindowClass.cbClsExtra    = 0;^M
    WindowClass.cbWndExtra    = 0;^M
    WindowClass.hInstance     = Instance;^M
    WindowClass.hIcon         = LoadIcon(Instance, MAKEINTRESOURCE(IDI_APPLICATION));^M
    WindowClass.hCursor       = LoadCursor(NULL, IDC_ARROW);^M
    WindowClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);^M
    WindowClass.lpszMenuName  = NULL;^M
    WindowClass.lpszClassName = TITLE;^M
    WindowClass.hIconSm       = LoadIcon(WindowClass.hInstance, MAKEINTRESOURCE(IDI_APPLICATION));^M
^M
    if (!RegisterClassEx(&WindowClass))^M
    {^M
        MessageBox(NULL,^M
            _T("Call to RegisterClassEx failed!"),^M
            TITLE,^M
            NULL);^M
^M
        return EXIT_FAILURE;^M
    }^M
^M
^M
^M
    // Set up window.^M
    // @todo get current screen size to put window in center^M
    MyWindow = CreateWindow(^M
        WindowClass.lpszClassName,^M
        TITLE,^M
        WS_OVERLAPPEDWINDOW,^M
        490, 500,^M
        1000, 1,^M
        NULL,^M
        NULL,^M
        Instance,^M
        NULL^M
    );^M
^M
    if (!MyWindow)^M
    {^M
        MessageBox(^M
            NULL,^M
            _T("Call to CreateWindow failed!"),^M
            TITLE,^M
            NULL);^M
^M
        return EXIT_FAILURE;^M
    }^M
^M
    // Set the window's styles.^M
    // @todo use CreateWindowEx instead of manually setting the styles after creation.^M
    {^M
        LONG normalStyles = GetWindowLong(MyWindow, GWL_STYLE);^M
        normalStyles &= ~(WS_CAPTION | WS_THICKFRAME | WS_MINIMIZE | WS_MAXIMIZE | WS_SYSMENU);^M
        SetWindowLongPtr(MyWindow, GWL_STYLE, normalStyles);^M
^M
        LONG extendedStyles = GetWindowLong(MyWindow, GWL_EXSTYLE);^M
        extendedStyles &= ~(WS_EX_DLGMODALFRAME | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE | WS_EX_TOPMOST);^M
        SetWindowLongPtr(MyWindow, GWL_EXSTYLE, extendedStyles);^M
    }^M
^M
    SetWindowPos(MyWindow, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);^M
^M
^M
    // @todo only show window on click or keyboard shortcut.^M
    //ShowWindow(MyWindow, nCmdShow);^M
    UpdateWindow(MyWindow);^M
^M
^M
^M
    // Set up cleanner upper for the notification icon no matter what happens. (Except stopping debugging still leaves garbage in the tray.)^M
    SetUnhandledExceptionFilter(UnexpectedExitHandler);^M
^M
^M
    ^M
    // Set up tray icon menu.^M
    IconMenu = CreatePopupMenu();^M
    AppendMenu(IconMenu, MF_STRING,    IconMenu_RunCancel, L"Run");^M
    AppendMenu(IconMenu, MF_SEPARATOR, 0,                  NULL);^M
    AppendMenu(IconMenu, MF_STRING,    IconMenu_Exit,      L"Exit");^M
^M
^M
^M
    // Set up tray icon.^M
    IconData.cbSize           = sizeof(NOTIFYICONDATA);^M
    IconData.hWnd             = MyWindow;^M
    IconData.uID              = 0;^M
    // {DB649CB7-81B4-4638-A97D-25552A45D5C8}^M
    IconData.guidItem         = { 0xdb649cb7, 0x81b4, 0x4638,{ 0xa9, 0x7d, 0x25, 0x55, 0x2a, 0x45, 0xd5, 0xc8 } };^M
    IconData.hBalloonIcon     = NULL;^M
    IconData.uFlags           = NIF_ICON | NIF_MESSAGE | NIF_TIP | NIF_GUID;^M
    IconData.uCallbackMessage = IconMessage;^M
    IconData.dwState          = 0;^M
    IconData.dwStateMask      = 0;^M
    IconData.uVersion         = NOTIFYICON_VERSION_4;^M
    IconData.dwInfoFlags      = 0;^M
    IconData.hIcon = LoadIcon(NULL, IDI_ASTERISK);^M
    StringCchCopy(IconData.szTip,       ARRAYSIZE(IconData.szTip),       TITLE);^M
    StringCchCopy(IconData.szInfoTitle, ARRAYSIZE(IconData.szInfoTitle), TITLE);^M
    StringCchCopy(IconData.szInfo,      ARRAYSIZE(IconData.szInfo),      TITLE);^M
^M
    // Add the icon.^M
    BOOL wasIconCreated = Shell_NotifyIcon(NIM_ADD, &IconData);^M
    if (!wasIconCreated)^M
    {^M
        // Most likely there is an instance of the icon left from a previous run.^M
        // Try to delete the existing instance.^M
        Shell_NotifyIcon(NIM_DELETE, &IconData);^M
^M
        // Try to create an instance for this run.^M
        wasIconCreated = Shell_NotifyIcon(NIM_ADD, &IconData);^M
        if (!wasIconCreated)^M
        {^M
            // @log unable to start, couldn't create shell icon.^M
            MessageBox(^M
                MyWindow,^M
                L"Call to Shell_NotifyIcon failed!",^M
                TITLE,^M
                NULL);^M
^M
            return EXIT_FAILURE;^M
        }^M
    }^M
^M
^M
    ^M
    // Load and parse config file.^M
    LoadConfigFile();^M
^M
^M
^M
    // Set up raw input.^M
    rawKeyboard.dwFlags     = RIDEV_NOLEGACY | RIDEV_INPUTSINK;^M
    rawKeyboard.usUsagePage = 1;^M
    rawKeyboard.usUsage     = 6;^M
    rawKeyboard.hwndTarget  = MyWindow;^M
    RegisterRawInputDevices(&rawKeyboard, 1, sizeof(rawKeyboard));^M
^M
^M
^M
    ^M
    // Main message loop.^M
    MSG msg;^M
    while (GetMessage(&msg, NULL, 0, 0))^M
    {^M
        TranslateMessage(&msg);^M
        DispatchMessage(&msg);^M
    }^M
    ^M
^M
^M
    return (int)msg.wParam;^M
}^M
^M
void^M
CleanupStuff()^M
{^M
    // @todo try to delete temp file(s).^M
^M
    UnhookWindowsHookEx(KeyboardHook);^M
    Shell_NotifyIcon(NIM_DELETE, &IconData);^M
^M
    if (My_Out != NULL && My_Out != INVALID_HANDLE_VALUE)^M
    {^M
        if(!CloseHandle(My_Out))^M
        {^M
            printf("Couldn't close My_Out!\n");^M
        }^M
^M
        My_Out = NULL;^M
    }^M
^M
    if (isChildRunning)^M
    {^M
        TerminateChild();^M
    }^M
}^M
^M
void^M
TerminateChild()^M
{    ^M
    if (ChildProcInfo.hProcess != NULL && ChildProcInfo.hProcess != INVALID_HANDLE_VALUE)^M
    {^M
        // TerminateProcess closes the handle.^M
        if(TerminateProcess(ChildProcInfo.hProcess, 0))^M
        {^M
            isChildRunning = false;^M
        }^M
        else^M
        {^M
            // @log error terminating process^M
            printf("Couldn't terminate process!\n");^M
^M
            if(!CloseHandle(ChildProcInfo.hProcess)) printf("Couldn't close handle to child process!\n");^M
^M
            ChildProcInfo = { 0 };^M
        } ^M
^M
^M
        if (Child_In_Read != NULL && Child_In_Read != INVALID_HANDLE_VALUE)^M
        {^M
            if(!CloseHandle(Child_In_Read))^M
            {^M
                printf("Couldn't close Child_In_Read!\n");^M
            }^M
^M
            Child_In_Read = NULL;^M
        }^M
^M
        if (Child_In_Write != NULL && Child_In_Write != INVALID_HANDLE_VALUE)^M
        {^M
            if(!CloseHandle(Child_In_Write))^M
            {^M
                printf("Couldn't close Child_In_Write!\n");^M
            }^M
^M
            Child_In_Write = NULL;^M
        }^M
^M
        if (Child_Out_Read != NULL && Child_Out_Read != INVALID_HANDLE_VALUE)^M
        {^M
            if(!CloseHandle(Child_Out_Read))^M
            {^M
                printf("Couldn't close Child_Out_Read!\n");^M
            }^M
^M
            Child_Out_Read = NULL;^M
        }^M
^M
        if (Child_Out_Write != NULL && Child_Out_Write != INVALID_HANDLE_VALUE)^M
        {^M
            if(!CloseHandle(Child_Out_Write))^M
            {^M
                printf("Couldn't close Child_Out_Write!\n");^M
            }^M
^M
            Child_Out_Write = NULL;^M
        }^M
    }^M
}^M
^M
void^M
Cancel()^M
{^M
    if (!isChildRunning)^M
    {^M
        printf("Nothing to cancel.\n");^M
        return;^M
    }^M
^M
    ^M
    printf("Attempting to stop...\n");^M
    wasChildCancelled = true;^M
    TerminateChild();^M
    return;^M
}^M
^M
void^M
Run(char *command)^M
{^M
    if (isChildRunning)^M
    {^M
        return;^M
    }^M
^M
    printf("Running.\n");^M
    ^M
    // Get clipboard data.^M
    if (!OpenClipboard(MyWindow))^M
    {^M
        // @log err.^M
        printf("Couldn't open the clipboard!\n");^M
        return;^M
    }^M
^M
^M
^M
    // Find out which type of data we are dealing with.^M
    // Right now just handling text and bitmap.^M
    // Other possible options:^M
    //   CF_HDROP: Selected file in explorer.^M
    //   CF_WAVE: Wave file.^M
    UINT firstFormat = EnumClipboardFormats(0);^M
    UINT currentFormat = firstFormat;^M
    bool isText = false;^M
    do^M
    {^M
        switch (currentFormat)^M
        {^M
            case CF_UNICODETEXT:^M
            {^M
                isText = true;^M
                break;^M
            }^M
^M
            default:^M
            {^M
                currentFormat = EnumClipboardFormats(currentFormat);^M
                break;^M
            }^M
        }^M
^M
    } while (currentFormat != firstFormat && !isText);^M
    ^M
^M
^M
    if (isText)^M
    {^M
        HGLOBAL textDataHandle = GetClipboardData(CF_UNICODETEXT);^M
        if (textDataHandle == NULL)^M
        {^M
            // @log err^M
            goto textData_cleanup;^M
        }^M
^M
        wchar_t *wideText = static_cast<wchar_t*>(GlobalLock(textDataHandle));^M
        if (wideText == NULL)^M
        {^M
            // @log err^M
            goto textData_cleanup;^M
        }^M
^M
        const int text_size = 200000;^M
        int text_numBytes = 0;^M
        char text[text_size];^M
        {^M
            text_numBytes =^M
                WideCharToMultiByte(^M
                    CP_UTF8,^M
                    NULL,      // Must be set to NULL for CP_UTF8?^M
                    wideText,^M
                    -1,        // Null terminated, so no size needed.^M
                    text,^M
                    text_size,^M
                    NULL,      // Must be set to NULL for CP_UTF8.^M
                    NULL);     // Must be set to NULL for CP_UTF8.^M
^M
            text[text_numBytes] = '\0';^M
        }^M
^M
^M
        // Start of child process creation.^M
        SECURITY_ATTRIBUTES secAttr;^M
        secAttr.nLength              = sizeof(secAttr);^M
        secAttr.bInheritHandle       = true;^M
        secAttr.lpSecurityDescriptor = NULL;^M
^M
        // Create and initialize standard in pipe.^M
        {^M
            bool createPipeSuccess =^M
                CreatePipe(^M
                    &Child_In_Read,^M
                    &Child_In_Write,^M
                    &secAttr,^M
                    0);^M
            if (!createPipeSuccess)^M
            {^M
                // @logging log error.^M
                printf("Could not create standard in pipe!\n");^M
                goto textData_cleanup;^M
            }^M
^M
            bool setPipeFlagSuccess = SetHandleInformation(Child_In_Write, HANDLE_FLAG_INHERIT, 0);^M
            if (!setPipeFlagSuccess)^M
            {^M
                // @logging log error.^M
                printf("Could not set standard in pipe information!\n");^M
                goto textData_cleanup;^M
            }^M
        }^M
^M
        ^M
        // Create and initialize standard out pipe.^M
        {^M
            bool createPipeSuccess =^M
                CreatePipe(^M
                    &Child_Out_Read,^M
                    &Child_Out_Write,^M
                    &secAttr,^M
                    0);^M
            if (!createPipeSuccess)^M
            {^M
                // @logging log error.^M
                printf("Could not create standard out pipe!\n");^M
                goto textData_cleanup;^M
            }^M
^M
            bool setPipeFlagSuccess =^M
                SetHandleInformation(^M
                    Child_Out_Read,^M
                    HANDLE_FLAG_INHERIT,^M
                    0);^M
            if (!setPipeFlagSuccess)^M
            {^M
                // @logging log error.^M
                printf("Could not set standard out pipe information!\n");^M
                goto textData_cleanup;^M
            }^M
        }       ^M
        ^M
        wchar_t tempFileNameAndPath[MAX_PATH];^M
        {^M
            TCHAR tempPath[MAX_PATH];^M
            GetTempPath(MAX_PATH, tempPath);^M
        ^M
            // GetTempFileName CREATES A FILE IF IT SUCCEEDS.^M
            GetTempFileName(tempPath, TITLE, 0, tempFileNameAndPath);^M
            printf("Temp file path and name: %ls\n", tempFileNameAndPath);^M
^M
            char openFileName[MAX_PATH];^M
            HANDLE tempFile =^M
                CreateFile(^M
                    tempFileNameAndPath,^M
                    GENERIC_WRITE,^M
                    0,^M
                    NULL,^M
                    OPEN_EXISTING, ^M
                    FILE_ATTRIBUTE_NORMAL,^M
                    NULL); ^M
            ^M
            DWORD tempBytesWritten = 0;^M
            bool writeSuccess =^M
                WriteFile(^M
                    tempFile,^M
                    text,^M
                    text_numBytes,^M
                    &tempBytesWritten,^M
                    NULL);^M
            if (!writeSuccess)^M
            {^M
                // @logging log error.^M
                printf("Could not write to temp file!\n");^M
                goto textData_cleanup;^M
            }^M
^M
            ^M
            CloseHandle(tempFile);^M
        }^M
^M
^M
        // Build command string.^M
        const int commandLine_size = 200000;^M
        wchar_t commandLine[commandLine_size];^M
        commandLine[0] = '\0';^M
^M
        {^M
            // Add command as zeroith argument.^M
            wchar_t convertedCommand[command_size];^M
            size_t numConverted = 0;^M
            mbstowcs_s(&numConverted, convertedCommand, command, _TRUNCATE);^M
            wcscat_s(commandLine, L"cmd /C \"");^M
            wcscat_s(commandLine, convertedCommand);^M
            wcscat_s(commandLine, L"\"");^M
^M
            /*^M
            // Add temp file path as the first argument.^M
            wcscat_s(commandLine, tempFileNameAndPath);^M
            wcscat_s(commandLine, L" ");^M
            ^M
            // Add clipboard data for the remaining arguments.^M
            wcscat_s(commandLine, wideText);^M
            */^M
^M
            printf("commandLine: %ls\n", commandLine);^M
        }^M
^M
^M
  ^M
        // Create the child process.^M
        {^M
            STARTUPINFO startupInfo = { 0 };^M
            startupInfo.cb         = sizeof(startupInfo);^M
            startupInfo.hStdInput  = Child_In_Read;^M
            startupInfo.hStdError  = Child_Out_Write;^M
            startupInfo.hStdOutput = Child_Out_Write;^M
            startupInfo.dwFlags    = STARTF_USESTDHANDLES;^M
^M
            bool createProcessSuccess = CreateProcessW(^M
                NULL,^M
                commandLine,^M
                NULL,^M
                NULL,^M
                true,^M
                0,^M
                NULL,^M
                NULL,^M
                &startupInfo,^M
                &ChildProcInfo);        ^M
            if (!createProcessSuccess)^M
            {^M
                printf("Could not start child process with command line: %ls", commandLine);^M
                goto textData_cleanup;^M
            }^M
^M
            isChildRunning = true;^M
            ModifyMenu(IconMenu, IconMenu_RunCancel, MF_BYCOMMAND, IconMenu_RunCancel, L"Cancel");^M
^M
            // newHandle is always 0x00000000 so I'm assuming I don't need to clean it up.^M
            HANDLE newHandle;^M
            RegisterWaitForSingleObject(&newHandle, ChildProcInfo.hProcess, LaunchedProcessExitedOrCancelled, NULL, INFINITE, WT_EXECUTEONLYONCE);^M
^M
            ^M
        ^M
            // Need to write to standard in in chuncks...? Still "crashing" on simple cat, but not cat | grep.^M
            {^M
                int bytesLeftToWrite = text_numBytes;^M
                while (bytesLeftToWrite > 128)^M
                {^M
                    int startingOffset = text_numBytes - bytesLeftToWrite;^M
                    DWORD inBytesWritten = 0;^M
                    bool writeSuccess =^M
                        WriteFile(^M
                            Child_In_Write,^M
                            text + startingOffset,^M
                            128,^M
                            &inBytesWritten,^M
                            NULL);^M
                    if (!writeSuccess)^M
                    {^M
                        // @logging log error.^M
                        printf("Could not write to child's standard in!\n");^M
                        goto textData_cleanup;^M
                    }^M
^M
                    bytesLeftToWrite -= inBytesWritten;^M
                }^M
^M
                assert(bytesLeftToWrite >= 0);^M
^M
                if (bytesLeftToWrite > 0)^M
                {                    ^M
                    int startingOffset = text_numBytes - bytesLeftToWrite;^M
                    DWORD inBytesWritten = 0;^M
                    bool writeSuccess =^M
                        WriteFile(^M
                            Child_In_Write,^M
                            text + startingOffset,^M
                            bytesLeftToWrite,^M
                            &inBytesWritten,^M
                            NULL);^M
                    if (!writeSuccess)^M
                    {^M
                        // @logging log error.^M
                        printf("Could not write to child's standard in!\n");^M
                        goto textData_cleanup;^M
                    }^M
                }^M
^M
^M
            }^M
^M
            CloseHandle(Child_In_Write);^M
        }^M
        ^M
    textData_cleanup:^M
        // GlobalUnlock makes the handle invalid - no need to call CloseHandle.^M
        GlobalUnlock(textDataHandle);^M
    }^M
    else^M
    {^M
        // Error or no data.^M
        goto clipboard_cleanup;^M
    }^M
^M
clipboard_cleanup:^M
    CloseClipboard();^M
}^M
^M
void^M
HandleIconMessage(LPARAM message)^M
{^M
    switch (message)^M
    {^M
        case WM_LBUTTONDBLCLK:^M
        {^M
            if (isWindowShowing)^M
            {^M
                isWindowShowing = false;^M
                ShowWindow(MyWindow, SW_HIDE);^M
            }^M
            else^M
            {^M
                isWindowShowing = true;^M
                ShowWindow(MyWindow, SW_RESTORE);^M
            }^M
            break;^M
        }^M
^M
        case WM_RBUTTONDOWN:^M
        {^M
            POINT CursorPoint;^M
            GetCursorPos(&CursorPoint);^M
^M
            SetForegroundWindow(MyWindow);^M
^M
            UINT clicked =^M
                TrackPopupMenu(^M
                    IconMenu,^M
                    TPM_RETURNCMD | TPM_NONOTIFY,^M
                    CursorPoint.x,^M
                    CursorPoint.y,^M
                    0,^M
                    MyWindow,^M
                    NULL);^M
            switch (clicked)^M
            {^M
                case IconMenu_Exit:^M
                {^M
                    DestroyWindow(MyWindow);^M
                    break;^M
                }^M
^M
                case IconMenu_RunCancel:^M
                {^M
                    if (isChildRunning)^M
                    {^M
                        Cancel();^M
                    }^M
                    else^M
                    {^M
                        Run(Configs[0].command);^M
                    }^M
                    break;^M
                }^M
            }^M
^M
            break;^M
        }^M
    }^M
}^M
^M
LRESULT CALLBACK^M
WndProc(HWND Window, UINT message, WPARAM wParam, LPARAM lParam)^M
{^M
    switch (message)^M
    {^M
        case WM_INPUT:^M
        {^M
            HRAWINPUT rawInputParam = (HRAWINPUT)lParam;^M
            UINT size = 0;^M
^M
            {^M
                int result =^M
                    GetRawInputData(^M
                        rawInputParam,^M
                        RID_INPUT,^M
                        NULL,^M
                        &size,^M
                        sizeof(RAWINPUTHEADER));^M
                if (result == -1)^M
                {^M
                    break;^M
                }^M
            }^M
^M
            // @todo is this really needed? it's a lot of allocs...^M
            // replace with a big enough static buffer?^M
            char *buffer = new char[size];^M
            if (buffer == NULL)^M
            {^M
                goto buffer_cleanup;^M
            }^M
            ^M
            {^M
                int result =^M
                    GetRawInputData(^M
                        rawInputParam,^M
                        RID_INPUT,^M
                        buffer,^M
                        &size,^M
                        sizeof(RAWINPUTHEADER));^M
                if (result != size)^M
                {^M
                    goto buffer_cleanup;^M
                }^M
            }^M
^M
^M
^M
            PRAWINPUT input = (PRAWINPUT)buffer;^M
            int event = 0;^M
^M
            /*^M
            printf("Keyboard:\tmake: %04x flags: %04x reserved: %04x extra: %08x msg: %04x, vk: %04x\n",^M
                   input->data.keyboard.MakeCode,^M
                   input->data.keyboard.Flags,^M
                   input->data.keyboard.Reserved,^M
                   input->data.keyboard.ExtraInformation,^M
                   input->data.keyboard.Message,^M
                   input->data.keyboard.VKey);^M
            */^M
                                    ^M
            event = input->data.keyboard.Message;^M
^M
            // Build a comparable key name from the keyboard's scan code.^M
            // @todo clean up^M
            unsigned char key = MapVirtualKeyEx(input->data.keyboard.MakeCode, MAPVK_VSC_TO_VK_EX, NULL);^M
            wchar_t wideKeyName[255];^M
            wideKeyName[0] = '\0';^M
            GetKeyNameText(input->data.keyboard.MakeCode << 16, wideKeyName, 255);^M
            size_t numBytesConv = 0;^M
            char keyName[255];^M
            wcstombs_s(&numBytesConv, keyName, 255, wideKeyName, 255);^M
            char keyLetter = -1;^M
            const int sizeOfSingleWideChar = 2;^M
            if (numBytesConv == sizeOfSingleWideChar)^M
            {^M
                keyLetter = tolower(keyName[0]);^M
            }^M
^M
^M
            if (event == WM_KEYDOWN || event == WM_SYSKEYDOWN)^M
            {^M
^M
                if (key == VK_LCONTROL || key == VK_RCONTROL)^M
                {^M
                    modState |= Config_CONTROL;^M
                }^M
                else if (key == VK_LSHIFT || key == VK_RSHIFT)^M
                {^M
                    modState |= Config_SHIFT;^M
                }^M
                else if (key == VK_LMENU || key == VK_RMENU || key == VK_MENU)^M
                {^M
                    modState |= Config_ALT;^M
                }^M
^M
                // @todo don't hard code the cancel command.^M
                if (modState == (Config_CONTROL | Config_SHIFT | Config_ALT) &&^M
                    keyLetter == 'c')^M
                {^M
                    Cancel();^M
                }^M
^M
                for (int Configs_i = 0; Configs_i < Configs_count; Configs_i++)^M
                {^M
                    Config *currentConfig = &Configs[Configs_i];^M
                    ^M
                    if (modState == currentConfig->hotkeyMod &&^M
                        currentConfig->hotkey == keyLetter)^M
                    {^M
                        Run(currentConfig->command);^M
                    }^M
                }^M
^M
            }^M
            else if (event == WM_KEYUP || event == WM_SYSKEYUP)^M
            {       ^M
                if (key == VK_LCONTROL || key == VK_RCONTROL)^M
                {^M
                    modState &= ~Config_CONTROL;^M
                }^M
                else if (key == VK_LSHIFT || key == VK_RSHIFT)^M
                {^M
                    modState &= ~Config_SHIFT;^M
                }^M
                else if (key == VK_LMENU || key == VK_RMENU || key == VK_MENU)^M
                {^M
                    modState &= ~Config_ALT;^M
                };^M
            }^M
^M
^M
^M
        buffer_cleanup:^M
            delete[] buffer;^M
            buffer = NULL;^M
            input  = NULL;^M
^M
^M
^M
            break;^M
        }^M
^M
        case WM_PAINT:^M
        {^M
            PAINTSTRUCT paintStruct;^M
            HDC context = BeginPaint(MyWindow, &paintStruct);^M
^M
            wchar_t *message = L"Hi.";^M
            TextOut(context, 5, 5, message, wcslen(message));^M
^M
            EndPaint(Window, &paintStruct);^M
            break;^M
        }^M
^M
        case WM_DESTROY:^M
        {^M
            CleanupStuff();^M
            PostQuitMessage(0);^M
            break;^M
        }^M
^M
        case IconMessage:^M
        {^M
            HandleIconMessage(lParam);^M
            break;^M
        }^M
^M
        default:^M
        {^M
            return DefWindowProc(Window, message, wParam, lParam);^M
            break;^M
        }^M
    }^M
^M
    return 0;^M
}^M
^M
LONG WINAPI^M
UnexpectedExitHandler(PEXCEPTION_POINTERS pExceptionInfo)^M
{^M
    CleanupStuff();^M
^M
    return EXCEPTION_CONTINUE_SEARCH;^M
}^M
^M
BOOL WINAPI^M
ConsoleCtrlHandler(^M
    DWORD controlType^M
)^M
{^M
    switch (controlType)^M
    {^M
        case CTRL_C_EVENT:^M
        case CTRL_BREAK_EVENT:^M
        case CTRL_CLOSE_EVENT:^M
        {^M
            CleanupStuff();^M
            break;^M
        }^M
    }^M
^M
    return false; ^M
}^M
^M
VOID CALLBACK^M
LaunchedProcessExitedOrCancelled(PVOID lpParameter, BOOLEAN TimerOrWaitFired)^M
{^M
    isChildRunning = false;^M
    ModifyMenu(IconMenu, IconMenu_RunCancel, MF_BYCOMMAND, IconMenu_RunCancel, L"Run");^M
^M
    if (wasChildCancelled)^M
    {^M
        wasChildCancelled = false;^M
        printf("Child cancelled.\n");^M
        goto child_cleanup;^M
    }^M
^M
    printf("Child exited.\n");^M
^M
    // @todo delete temp file.^M
^M
    const int pipeBuffer_size = 200000;^M
    char *pipeBuffer = new char[pipeBuffer_size];^M
            ^M
    {^M
        // Read from processes' standard out.^M
        DWORD numBytesRead = 0;^M
        bool readSuccess = ReadFile(Child_Out_Read, pipeBuffer, pipeBuffer_size, &numBytesRead, NULL);^M
        if (!readSuccess)^M
        {^M
            // @logging log error.^M
            printf("Could not read from child's standard out!\n");^M
            goto pipeBuffer_cleanup;^M
        }^M
^M
        // Write to my standard out.^M
        DWORD numBytesWritten = 0;^M
        bool writeSuccess = WriteFile(My_Out, pipeBuffer, numBytesRead, &numBytesWritten, NULL);^M
        if (!writeSuccess)^M
        {^M
            // @logging log error.^M
            printf("Could not write to my standard out!\n");^M
            goto pipeBuffer_cleanup;^M
        }^M
^M
        // Write to global memory for clipboard.        ^M
        HANDLE clipboardMemory = GlobalAlloc(GMEM_MOVEABLE, numBytesRead);^M
        if (clipboardMemory == NULL)^M
        {^M
            // @logging log error.^M
            printf("Couldn't allocate global memory! Size:%d\n", numBytesRead);^M
            goto pipeBuffer_cleanup;^M
        }^M
^M
        HANDLE writeableClipboardMemory = GlobalLock(clipboardMemory);^M
        memcpy_s(writeableClipboardMemory, numBytesRead, pipeBuffer, numBytesRead);^M
        GlobalUnlock(writeableClipboardMemory);^M
        ^M
        printf("\n\n\nAttempting to open clipboard...\n");^M
    ^M
        if (!OpenClipboard(MyWindow))^M
        {^M
            // On failure, give up;^M
            // @log err.^M
            printf("Couldn't open the clipboard!\n");^M
            goto pipeBuffer_cleanup;^M
        }^M
^M
        EmptyClipboard();^M
        SetClipboardData(CF_TEXT, clipboardMemory);        ^M
        printf("Wrote to the clipboard!\n");^M
    }^M
    ^M
    printf("Back to normal.\n");^M
^M
^M
^M
clipboard_cleanup:^M
    CloseClipboard();^M
pipeBuffer_cleanup:    ^M
    delete[] pipeBuffer;^M
child_cleanup:^M
    ChildProcInfo = { 0 };^M
}^M
^@